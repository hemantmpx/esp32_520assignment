// Final drop-in sketch
// ESP32 NimBLE HID Mouse (no security attempt) + SSD1306 OLED status
// - NimBLE-Arduino (h2zero/NimBLE-Arduino) required
// - Adafruit GFX + Adafruit SSD1306 required
// - No calls to startSecurity()/setSecurityAuth(true,..) â€” peripheral avoids initiating security
// - Displays state on OLED: INIT / ADVERTISING / CONNECTED (Unencrypted) / DISCONNECTED
//
// Wiring for typical SSD1306 I2C:
//   SDA -> GPIO21
//   SCL -> GPIO22
//   VCC -> 3.3V
//   GND -> GND
//
// Paste into PlatformIO/Arduino and upload.

#include <NimBLEDevice.h>
#include <NimBLEHIDDevice.h>
#include <NimBLECharacteristic.h>

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <math.h>
#include <string.h>

// ---------- CONFIG ----------
const char* DEVICE_NAME = "ESP32-NoSec-FakeMouse";
uint8_t manufData[] = { 'H','U','P','A','D' }; // simple manufacturer bytes

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET    -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
bool oledAvailable = false;

// HID / NimBLE globals
NimBLEServer* pServer = nullptr;
NimBLEHIDDevice* hid = nullptr;
NimBLECharacteristic* inputMouse = nullptr;

// connection state
volatile bool gConnected = false;

// Movement state (circle)
int16_t lastX = 0, lastY = 0;
float angleStep = 0.25f;
float anglePos = 0.0f;
const float circleRadius = 8.0f;
unsigned long lastMoveMs = 0;
const unsigned long moveIntervalMs = 40;

// HID Report Map: 3-byte relative mouse [buttons, x, y]
static const uint8_t REPORT_MAP[] = {
  0x05,0x01,0x09,0x02,0xA1,0x01,
    0x09,0x01,0xA1,0x00,
      0x05,0x09,0x19,0x01,0x29,0x03,
      0x15,0x00,0x25,0x01,0x95,0x03,0x75,0x01,0x81,0x02,
      0x95,0x01,0x75,0x05,0x81,0x01,
      0x05,0x01,0x09,0x30,0x09,0x31,
      0x15,0x81,0x25,0x7F,0x75,0x08,0x95,0x02,0x81,0x06,
    0xC0,
  0xC0
};

// ---------- OLED helpers ----------
void oledInit() {
  Wire.begin(21, 22); // SDA, SCL
  // Try to initialize; display.begin returns true on success (Adafruit SSD1306)
  if (display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    oledAvailable = true;
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0,0);
    display.println("ESP32 HID Mouse");
    display.display();
    delay(300);
  } else {
    oledAvailable = false;
  }
}

void oledShowStatus(const char* line1, const char* line2, const char* line3 = "") {
  if (!oledAvailable) return;
  display.clearDisplay();
  display.setTextSize(1);
  display.setCursor(0,0);
  display.println(DEVICE_NAME);
  display.println();
  display.println(line1);
  display.println(line2);
  if (line3 && strlen(line3)) display.println(line3);
  display.display();
}

// ---------- Callbacks ----------
class ServerCallbacks : public NimBLEServerCallbacks {
  void onConnect(NimBLEServer* server) override {
    gConnected = true;
    Serial.println("Client connected (no encryption requested by peripheral).");
    oledShowStatus("STATE: CONNECTED", "Unencrypted");
  }

  void onDisconnect(NimBLEServer* server) override {
    gConnected = false;
    lastX = lastY = 0;
    Serial.println("Client disconnected - restarting advertising.");
    oledShowStatus("STATE: ADVERTISING", "Unencrypted");
    NimBLEDevice::startAdvertising();
  }
};

// ---------- HID helpers ----------
void sendMouseReport(uint8_t buttons, int8_t dx, int8_t dy) {
  if (!inputMouse) return;
  if (!pServer) return;
  if (pServer->getConnectedCount() == 0) return;

  uint8_t report[3];
  report[0] = buttons & 0x07;
  report[1] = (uint8_t)dx;
  report[2] = (uint8_t)dy;

  inputMouse->setValue(report, sizeof(report));
  inputMouse->notify();
}

void sendLeftClick() {
  sendMouseReport(0x01, 0, 0);
  delay(30);
  sendMouseReport(0x00, 0, 0);
}

// ---------- Setup ----------
void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\n=== ESP32 BLE HID Mouse (no security attempt) + OLED ===");

  oledInit();
  if (oledAvailable) oledShowStatus("STATE: INIT", "");

  // NimBLE init
  NimBLEDevice::init(DEVICE_NAME);

  // Strongly bias NimBLE to not participate in security
  NimBLEDevice::setSecurityAuth(false, false, false); // no bonding, no MITM, no SC
  NimBLEDevice::setSecurityIOCap(BLE_HS_IO_NO_INPUT_OUTPUT); // no I/O
  NimBLEDevice::setSecurityInitKey(0); // do not initiate keys
  NimBLEDevice::setSecurityRespKey(0); // do not accept keys

  // Use random static address (typical)
  NimBLEDevice::setOwnAddrType(BLE_OWN_ADDR_RANDOM);

  // Create server & callbacks
  pServer = NimBLEDevice::createServer();
  pServer->setCallbacks(new ServerCallbacks());

  // Create HID device
  hid = new NimBLEHIDDevice(pServer);
  inputMouse = hid->inputReport(1); // report ID 1

  hid->manufacturer()->setValue("HUPAD Inc.");
  hid->pnp(0x02, 0x045E, 0x028E, 0x0110);
  hid->hidInfo(0x00, 0x01);

  // Report map and start services
  hid->reportMap((uint8_t*)REPORT_MAP, sizeof(REPORT_MAP));
  hid->startServices();

  // Advertising setup (legacy ADV by default)
  NimBLEAdvertising* pAdv = NimBLEDevice::getAdvertising();
  pAdv->setAppearance(962); // Generic Mouse
  pAdv->addServiceUUID(NimBLEUUID((uint16_t)0x1812)); // HID

  std::string mdf((char*)manufData, sizeof(manufData));
  pAdv->setManufacturerData(mdf);

  pAdv->setScanResponse(false);
  pAdv->start();

  oledShowStatus("STATE: ADVERTISING", "Unencrypted");
  Serial.println("Advertising started (attempting to avoid security).");
}

// ---------- Loop ----------
void loop() {
  unsigned long now = millis();

  // Movement: circular motion & occasional clicks when connected
  if (gConnected && (now - lastMoveMs >= moveIntervalMs)) {
    lastMoveMs = now;

    float newXf = circleRadius * cos(anglePos);
    float newYf = circleRadius * sin(anglePos);

    int16_t newX = (int16_t)round(newXf);
    int16_t newY = (int16_t)round(newYf);

    int8_t dx = (int8_t)constrain((int)newX - (int)lastX, -127, 127);
    int8_t dy = (int8_t)constrain((int)newY - (int)lastY, -127, 127);

    sendMouseReport(0x00, dx, dy);

    lastX = newX;
    lastY = newY;

    anglePos += angleStep;
    if (anglePos > (2.0f * M_PI)) {
      anglePos -= (2.0f * M_PI);
      // occasional jitter / click
      if (random(0, 10) > 6) sendMouseReport(0x00, (int8_t)random(-6,6), (int8_t)random(-6,6));
      if (random(0, 10) > 8) {
        sendLeftClick();
      }
    }
  }

  // Periodically refresh OLED to reflect current state if not connected
  static unsigned long lastStatus = 0;
  if (millis() - lastStatus > 1200) {
    lastStatus = millis();
    if (oledAvailable) {
      if (!gConnected) oledShowStatus("STATE: ADVERTISING", "Unencrypted");
      else oledShowStatus("STATE: CONNECTED", "Unencrypted");
    }
  }

  delay(2);
}
