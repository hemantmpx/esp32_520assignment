// ESP32 NimBLE HID Mouse + OLED status (clean, compiles with NimBLE-Arduino v1.4.x)
// - Advertises with device name + manufacturer data fingerprint
// - Starts BLE security (bonding) when a central connects
// - Sends circular/random mouse motion while client is connected
// - Shows Advertising / Connected (Pairing started) / Connected (Paired: N/A) on OLED
//
// Libraries required:
//   - h2zero/NimBLE-Arduino
//   - Adafruit GFX
//   - Adafruit SSD1306

#include <NimBLEDevice.h>
#include <NimBLEHIDDevice.h>
#include <NimBLECharacteristic.h>

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <math.h>
#include <string.h>

// ---------- CONFIG ----------
const char* DEVICE_NAME = "ESP32-Hemant-FakeMouse";
uint8_t manufData[] = { 0x48, 0x55, 0x50, 0x41, 0x44 }; // "HUPAD"

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET    -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
bool oledAvailable = false;

// HID / NimBLE globals
NimBLEServer* pServer = nullptr;
NimBLEHIDDevice* hid = nullptr;
NimBLECharacteristic* inputMouse = nullptr;

// connection state
volatile bool gConnected = false;
volatile uint16_t gConnHandle = 0;

// Movement state (circle)
int16_t lastX = 0, lastY = 0;
float angleStep = 0.25f;
float anglePos = 0.0f;
const float circleRadius = 8.0f;
unsigned long lastMoveMs = 0;
const unsigned long moveIntervalMs = 40;

// HID Report Map: 3-byte relative mouse [buttons, x, y]
static const uint8_t REPORT_MAP[] = {
  0x05,0x01,0x09,0x02,0xA1,0x01,
    0x09,0x01,0xA1,0x00,
      0x05,0x09,0x19,0x01,0x29,0x03,
      0x15,0x00,0x25,0x01,0x95,0x03,0x75,0x01,0x81,0x02,
      0x95,0x01,0x75,0x05,0x81,0x01,
      0x05,0x01,0x09,0x30,0x09,0x31,
      0x15,0x81,0x25,0x7F,0x75,0x08,0x95,0x02,0x81,0x06,
    0xC0,
  0xC0
};

// ---------- OLED helpers ----------
void oledInit() {
  Wire.begin(21, 22); // SDA, SCL (default typical pins)
  // try begin; set flag
  if (display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    oledAvailable = true;
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0,0);
    display.println("ESP32 HID Mouse");
    display.display();
  } else {
    oledAvailable = false;
  }
}

void oledShowStatus(const char* line1, const char* line2, const char* line3 = "") {
  if (!oledAvailable) return;
  display.clearDisplay();
  display.setTextSize(1);
  display.setCursor(0,0);
  display.println(DEVICE_NAME);
  display.println();
  display.println(line1);
  display.println(line2);
  if (line3 && strlen(line3)) display.println(line3);
  display.display();
}

// ---------- Callbacks ----------
class ServerCallbacks : public NimBLEServerCallbacks {
  void onConnect(NimBLEServer* server) override {
    gConnected = true;
    // get peer connection handles (if any)
    std::vector<uint16_t> peers = server->getPeerDevices();
    if (!peers.empty()) {
      gConnHandle = peers[0];
      // Request pairing / security for this connection
      NimBLEDevice::startSecurity(gConnHandle);
    } else {
      gConnHandle = 0;
    }

    oledShowStatus("STATE: CONNECTED", "Pairing: STARTED");
    Serial.println("Client connected - started pairing/security");
  }

  void onDisconnect(NimBLEServer* server) override {
    gConnected = false;
    gConnHandle = 0;
    lastX = lastY = 0;
    oledShowStatus("STATE: ADVERTISING", "Paired: N/A");
    Serial.println("Client disconnected - advertising restarted");
    NimBLEDevice::startAdvertising();
  }
};

// ---------- HID helpers ----------
void sendMouseReport(uint8_t buttons, int8_t dx, int8_t dy) {
  if (!inputMouse) return;
  if (!pServer) return;
  if (pServer->getConnectedCount() == 0) return;

  uint8_t report[3];
  report[0] = buttons & 0x07;
  report[1] = (uint8_t)dx;
  report[2] = (uint8_t)dy;

  inputMouse->setValue(report, sizeof(report));
  inputMouse->notify();
}

void sendLeftClick() {
  sendMouseReport(0x01, 0, 0);
  delay(30);
  sendMouseReport(0x00, 0, 0);
}

// ---------- Setup ----------
void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\n=== ESP32 NimBLE HID Mouse with OLED ===");

  oledInit();
  if (oledAvailable) oledShowStatus("STATE: INIT", "");

  // seed RNG for occasional random motion
  randomSeed(analogRead(0));

  // NimBLE init
  NimBLEDevice::init(DEVICE_NAME);

  // Security: enable bonding (true), MITM=false, SC=true where available
  NimBLEDevice::setSecurityAuth(true, false, true);
  // set a passkey if you want numeric compare/passkey flows (optional)
  // NimBLEDevice::setSecurityPasskey(123456);
  NimBLEDevice::setOwnAddrType(BLE_OWN_ADDR_RANDOM);

  // Create server and callbacks
  pServer = NimBLEDevice::createServer();
  pServer->setCallbacks(new ServerCallbacks());

  // Create HID device and report
  hid = new NimBLEHIDDevice(pServer);
  inputMouse = hid->inputReport(1);

  hid->manufacturer()->setValue("HUPAD Inc.");
  hid->pnp(0x02, 0x045E, 0x028E, 0x0110);
  hid->hidInfo(0x00, 0x01);

  hid->reportMap((uint8_t*)REPORT_MAP, sizeof(REPORT_MAP));
  hid->startServices();

  // Advertising
  NimBLEAdvertising* pAdv = NimBLEDevice::getAdvertising();
  pAdv->setAppearance(962); // Generic Mouse
  pAdv->addServiceUUID(NimBLEUUID((uint16_t)0x1812)); // HID

  // Set manufacturer data (advertising payload) using std::string
  std::string mdf((char*)manufData, sizeof(manufData));
  pAdv->setManufacturerData(mdf);

  pAdv->setScanResponse(false);
  pAdv->start();

  oledShowStatus("STATE: ADVERTISING", "Paired: N/A");
  Serial.println("Advertising started.");
}

// ---------- Loop (movement when connected) ----------
void loop() {
  unsigned long now = millis();

  // When a client is connected, drive circular motion (no strict requirement to be bonded)
  if (gConnected && (now - lastMoveMs >= moveIntervalMs)) {
    lastMoveMs = now;

    float newXf = circleRadius * cos(anglePos);
    float newYf = circleRadius * sin(anglePos);

    int16_t newX = (int16_t)round(newXf);
    int16_t newY = (int16_t)round(newYf);

    int8_t dx = (int8_t)(newX - lastX);
    int8_t dy = (int8_t)(newY - lastY);

    // clamp to -127..127
    if (dx > 127) dx = 127; if (dx < -127) dx = -127;
    if (dy > 127) dy = 127; if (dy < -127) dy = -127;

    sendMouseReport(0x00, dx, dy);

    lastX = newX;
    lastY = newY;

    anglePos += angleStep;
    if (anglePos > (2.0f * M_PI)) {
      anglePos -= (2.0f * M_PI);
      // occasional small random jolt
      if (random(0, 10) > 6) sendMouseReport(0x00, (int8_t)random(-6,6), (int8_t)random(-6,6));
      if (random(0, 10) > 7) sendLeftClick();
    }
  }

  // Periodically refresh OLED with current state
  static unsigned long lastStatus = 0;
  if (millis() - lastStatus > 1200) {
    lastStatus = millis();
    if (oledAvailable) {
      if (!gConnected) {
        oledShowStatus("STATE: ADVERTISING", "Paired: N/A");
      } else {
        oledShowStatus("STATE: CONNECTED", "Pairing: STARTED", "Paired: N/A");
      }
    }
  }

  delay(2); // yield
}
